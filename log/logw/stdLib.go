// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package logw

// Most of this code can be improved to fits the needs for others.
// Main reason for implementing this was to provide a basic leveled logger without
// any dependencies to third party packages.

import (
	"bytes"
	"fmt"
	"io"
	std "log"
	"os"

	"github.com/corestoreio/csfw/log"
	"github.com/corestoreio/csfw/util/bufferpool"
	"github.com/corestoreio/csfw/util/errors"
)

// AssignmentChar represents the assignment character between key-value pairs
var AssignmentChar = ": "

// Separator is the separator to use between key value pairs
var Separator = " "

const (
	LevelFatal int = iota + 1
	LevelInfo
	LevelDebug
)

// Log implements logging with Go's standard library
type Log struct {
	gw    io.Writer // global writer
	level int
	flag  int // global flag http://golang.org/pkg/log/#pkg-constants
	debug *std.Logger
	info  *std.Logger
	fatal *std.Logger
}

// Option can be used as an argument in NewStdLog to configure a standard logger.
type Option func(*Log)

// NewLog creates a new logger with 6 different sub loggers.
// You can use option functions to modify each logger independently.
// Default output goes to Stderr.
func NewLog(opts ...Option) *Log {
	sl := &Log{
		level: LevelInfo,
		gw:    os.Stderr,
		flag:  std.LstdFlags,
	}
	for _, o := range opts {
		o(sl)
	}
	if sl.debug == nil {
		sl.debug = std.New(sl.gw, "DEBUG ", sl.flag)
	}
	if sl.info == nil {
		sl.info = std.New(sl.gw, "INFO ", sl.flag)
	}
	if sl.fatal == nil {
		sl.fatal = std.New(sl.gw, "FATAL ", sl.flag)
	}
	return sl
}

// SetStdWriter sets the global writer for all loggers. This global writer can be
// overwritten by individual level options.
func WithStdWriter(w io.Writer) Option {
	return func(l *Log) {
		l.gw = w
	}
}

// WithFlag sets the global flag for all loggers.
// These flags define which text to prefix to each log entry generated by the Logger.
// This global flag can be overwritten by individual level options.
// Please see http://golang.org/pkg/log/#pkg-constants
func WithFlag(f int) Option {
	return func(l *Log) {
		l.flag = f
	}
}

// WithLevel sets the log level. See constants Level*
func WithLevel(level int) Option {
	return func(l *Log) {
		l.SetLevel(level)
	}
}

// WithDebug applies options for debug logging
func WithDebug(out io.Writer, prefix string, flag int) Option {
	return func(l *Log) {
		l.debug = std.New(out, prefix, flag)
	}
}

// WithInfo applies options for info logging
func WithInfo(out io.Writer, prefix string, flag int) Option {
	return func(l *Log) {
		l.info = std.New(out, prefix, flag)
	}
}

// WithFatal applies options for fatal logging
func WithFatal(out io.Writer, prefix string, flag int) Option {
	return func(l *Log) {
		l.fatal = std.New(out, prefix, flag)
	}
}

// New returns a new Logger that has this logger's context plus the given context
// This function panics if an argument is not of type StdOption.
func (l *Log) New(iOpts ...interface{}) log.Logger {
	var opts = make([]Option, len(iOpts), len(iOpts))
	for i, iopt := range iOpts {
		if o, ok := iopt.(Option); ok {
			opts[i] = o
		} else {
			panic("Arguments to New() can only be StdOption types!")
		}
	}
	return NewLog(opts...)
}

// Debug logs a debug entry.
func (l *Log) Debug(msg string, fields ...log.Field) {
	l.log(LevelDebug, msg, fields)
}

// Info logs an info entry.
func (l *Log) Info(msg string, fields ...log.Field) {
	l.log(LevelInfo, msg, fields)
}

// Fatal logs a fatal entry then panics.
func (l *Log) Fatal(msg string, fields ...log.Field) {
	l.log(LevelFatal, msg, fields)
}

// log logs a leveled entry. Panics if an unknown level has been provided.
func (l *Log) log(level int, msg string, fs log.Fields) {
	if l.level >= level {
		switch level {
		case LevelDebug:
			// l.debug.Print(stdFormat(msg, append(args, "in", getStackTrace())))
			l.debug.Print(stdFormat(msg, fs))
			break
		case LevelInfo:
			l.info.Print(stdFormat(msg, fs))
			break
		case LevelFatal:
			l.fatal.Panic(stdFormat(msg, fs))
			break
		default:
			panic("Unknown Log Level")
		}
	}
}

// IsDebug determines if this logger logs a debug statement.
func (l *Log) IsDebug() bool {
	return l.level >= LevelDebug
}

// IsInfo determines if this logger logs an info statement.
func (l *Log) IsInfo() bool {
	return l.level >= LevelInfo
}

// SetLevel sets the level of this logger.
func (l *Log) SetLevel(level int) {
	l.level = level
}

type stdEncoder struct {
	buf *bytes.Buffer
}

func (se stdEncoder) stdSetKV(key string, val interface{}) {
	se.buf.WriteString(Separator)
	if key == "" {
		key = "_"
	}
	se.buf.WriteString(key)
	se.buf.WriteString(AssignmentChar)
	se.buf.WriteString(fmt.Sprintf("%#v", val))
}

func (se stdEncoder) AddBool(k string, v bool) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddFloat64(k string, v float64) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddInt(k string, v int) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddInt64(k string, v int64) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddMarshaler(k string, v log.LogMarshaler) error {
	// se.stdSetKV( k, v.)
	return nil
}
func (se stdEncoder) AddObject(k string, v interface{}) {
	se.stdSetKV(k, v)
}
func (se stdEncoder) AddString(k string, v string) {
	se.stdSetKV(k, v)
}

func stdFormat(msg string, fs log.Fields) string {
	buf := bufferpool.Get()
	defer bufferpool.Put(buf)
	se := stdEncoder{buf}

	buf.WriteString(msg)
	if err := fs.AddTo(se); err != nil {
		buf.WriteString("Error")
		buf.WriteString(AssignmentChar)
		buf.WriteString(errors.PrintLoc(err))
	}
	buf.WriteRune('\n')
	return buf.String()
}
